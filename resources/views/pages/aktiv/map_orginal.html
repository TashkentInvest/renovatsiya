<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InvestUz - Interactive Investment Map</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }

        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .app-header {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            padding: 0 20px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .app-logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .app-title {
            font-size: 20px;
            font-weight: 600;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .lang-switcher {
            display: flex;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            overflow: hidden;
        }

        .lang-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .lang-btn.active {
            background: rgba(255,255,255,0.2);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            position: relative;
            display: flex;
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Control Panels */
        .control-panel {
            position: absolute;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
            max-height: 80vh;
            overflow-y: auto;
        }

        .layer-controls {
            top: 20px;
            right: 20px;
            width: 280px;
            padding: 20px;
        }

        .map-style-controls {
            top: 20px;
            left: 20px;
            width: 200px;
            padding: 15px;
        }

        .geojson-controls {
            bottom: 20px;
            right: 20px;
            width: 300px;
            padding: 20px;
        }

        .control-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Layer Toggle Buttons */
        .layer-button {
            width: 100%;
            padding: 12px 15px;
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
        }

        .layer-button:hover {
            border-color: #4f46e5;
            background: #f8fafc;
        }

        .layer-button.active {
            background: #4f46e5;
            color: white;
            border-color: #4f46e5;
        }

        .layer-button-content {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .count-badge {
            background: #ef4444;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            min-width: 20px;
            text-align: center;
        }

        .layer-button.active .count-badge {
            background: rgba(255,255,255,0.3);
        }

        /* Map Style Buttons */
        .style-button {
            width: 100%;
            padding: 10px 15px;
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 8px;
            font-size: 14px;
            text-align: center;
        }

        .style-button:hover {
            border-color: #4f46e5;
        }

        .style-button.active {
            background: #4f46e5;
            color: white;
            border-color: #4f46e5;
        }

        /* GeoJSON Controls */
        .file-input-group {
            margin-bottom: 15px;
        }

        .file-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .primary-btn {
            flex: 1;
            padding: 10px 15px;
            background: #4f46e5;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .primary-btn:hover {
            background: #4338ca;
        }

        .secondary-btn {
            flex: 1;
            padding: 10px 15px;
            background: white;
            color: #ef4444;
            border: 2px solid #ef4444;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .secondary-btn:hover {
            background: #ef4444;
            color: white;
        }

        .status-text {
            font-size: 12px;
            color: #666;
            background: #f8fafc;
            padding: 8px;
            border-radius: 6px;
            margin-top: 10px;
        }

        /* Layer List */
        .layer-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #f8fafc;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .layer-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .layer-actions {
            display: flex;
            gap: 5px;
        }

        .action-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .toggle-btn {
            background: #10b981;
            color: white;
        }

        .toggle-btn.hidden {
            background: #ef4444;
        }

        .remove-btn {
            background: #ef4444;
            color: white;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: 60px;
            right: -400px;
            width: 380px;
            height: calc(100vh - 60px);
            background: white;
            box-shadow: -4px 0 20px rgba(0,0,0,0.15);
            z-index: 1001;
            transition: right 0.3s ease;
            overflow-y: auto;
        }

        .sidebar.open {
            right: 0;
        }

        .sidebar-header {
            padding: 20px;
            background: #f8fafc;
            border-bottom: 1px solid #e1e5e9;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #e1e5e9;
        }

        .sidebar-content {
            padding: 20px;
        }

        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
            padding-bottom: 8px;
            border-bottom: 2px solid #e1e5e9;
        }

        .info-table {
            width: 100%;
            border-collapse: collapse;
        }

        .info-table td {
            padding: 8px 0;
            font-size: 14px;
            border-bottom: 1px solid #f3f4f6;
        }

        .info-table td:first-child {
            font-weight: 600;
            color: #666;
            width: 40%;
        }

        .info-table td:last-child {
            color: #333;
        }

        /* Badges */
        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .badge-renovation {
            background: #f3e8ff;
            color: #7c3aed;
        }

        .badge-investment {
            background: #dbeafe;
            color: #2563eb;
        }

        .badge-auction {
            background: #fed7aa;
            color: #ea580c;
        }

        .badge-sold {
            background: #dcfce7;
            color: #16a34a;
        }

        /* Loading */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e1e5e9;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Toast */
        .toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2001;
        }

        .toast {
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 10px;
            color: white;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: slideUp 0.3s ease;
        }

        .toast.info {
            background: #4f46e5;
        }

        .toast.success {
            background: #10b981;
        }

        .toast.warning {
            background: #f59e0b;
        }

        .toast.error {
            background: #ef4444;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Statistics Panel */
        .stats-panel {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 13px;
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stats-label {
            color: #666;
        }

        .stats-value {
            font-weight: 600;
            color: #333;
        }

        /* Popup Customization */
        .leaflet-popup-content {
            margin: 15px;
            font-size: 14px;
        }

        .popup-header {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
        }

        .popup-image {
            width: 100%;
            max-height: 150px;
            object-fit: cover;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .popup-details {
            font-size: 13px;
            line-height: 1.4;
        }

        .popup-details p {
            margin: 5px 0;
        }

        .popup-details strong {
            color: #333;
        }

        .details-btn {
            margin-top: 10px;
            padding: 8px 15px;
            background: #4f46e5;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .details-btn:hover {
            background: #4338ca;
        }

        /* Drag and Drop */
        .drag-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(79, 70, 229, 0.1);
            border: 3px dashed #4f46e5;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            font-size: 18px;
            color: #4f46e5;
            font-weight: 600;
        }

        .drag-overlay.active {
            display: flex;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .app-title {
                font-size: 16px;
            }

            .layer-controls,
            .geojson-controls {
                width: 260px;
                right: 10px;
            }

            .map-style-controls {
                width: 180px;
                left: 10px;
            }

            .sidebar {
                width: 100%;
                right: -100%;
            }

            .control-panel {
                max-height: 60vh;
            }
        }

        @media (max-width: 480px) {
            .app-header {
                padding: 0 15px;
            }

            .layer-controls,
            .geojson-controls,
            .map-style-controls {
                position: fixed;
                bottom: 20px;
                top: auto;
                left: 10px;
                right: 10px;
                width: auto;
                max-height: 40vh;
            }
        }

        /* Custom Marker Styles */
        .custom-marker {
            background: none !important;
            border: none !important;
        }

        .marker-icon {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .marker-renovation {
            background: #7c3aed;
        }

        .marker-investment {
            background: #2563eb;
        }

        .marker-auction {
            background: #ea580c;
        }

        .marker-sold {
            background: #dc2626;
        }

        .marker-regular {
            background: #059669;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- External Scripts -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // Constants
        const API_ENDPOINTS = {
            aktivs: '/api/aktivs',
            auction: 'https://projects.toshkentinvest.uz/api/markersing',
            sold: 'https://projects.toshkentinvest.uz/api/sotilgan',
            jsonData: '/assets/data/443_output.json'
        };

        const MAP_STYLES = {
            osm: {
                name: 'Standard',
                url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                attribution: '¬© OpenStreetMap contributors'
            },
            satellite: {
                name: 'Satellite',
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                attribution: '¬© Esri, Maxar, Earthstar Geographics'
            },
            hybrid: {
                name: 'Hybrid',
                baseUrl: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                labelUrl: 'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
                attribution: '¬© Esri, Maxar, Earthstar Geographics'
            }
        };

        // Utility Functions
        const initProj4 = () => {
            if (typeof proj4 !== 'undefined') {
                proj4.defs("EPSG:32642", "+proj=utm +zone=42 +datum=WGS84 +units=m +no_defs");
            }
        };

        const utmToLatLng = (x, y) => {
            try {
                if (typeof proj4 !== 'undefined') {
                    const lonLat = proj4("EPSG:32642", "EPSG:4326", [x, y]);
                    return [lonLat[1], lonLat[0]];
                }
            } catch (error) {
                console.warn('Coordinate conversion failed:', error);
            }
            return null;
        };

        const isUTM = (x, y) => Math.abs(x) > 180 || Math.abs(y) > 90;

        const convertCoordinates = (coords) => {
            if (isUTM(coords[0], coords[1])) {
                return utmToLatLng(coords[0], coords[1]);
            }
            return [coords[1], coords[0]];
        };

        const extractCoordinatesFromUrl = (url) => {
            if (!url) return null;

            try {
                const decodedUrl = decodeURIComponent(url);

                // Yandex Maps
                if (decodedUrl.includes('yandex.uz/maps') || decodedUrl.includes('yandex.com/maps')) {
                    const llMatch = decodedUrl.match(/ll=([^&]+)/);
                    if (llMatch) {
                        const coords = llMatch[1].split(',');
                        if (coords.length === 2) {
                            const lng = parseFloat(coords[0]);
                            const lat = parseFloat(coords[1]);
                            if (lat >= 39 && lat <= 43 && lng >= 68 && lng <= 71) {
                                return [lat, lng];
                            }
                        }
                    }
                }

                // Google Maps patterns
                const patterns = [
                    /@(-?\d+\.?\d*),(-?\d+\.?\d*),?\d*z?/,
                    /(-?\d+\.\d{4,}),(-?\d+\.\d{4,})/,
                    /!3d(-?\d+\.?\d*)!4d(-?\d+\.?\d*)/,
                    /\/place\/[^@]*@(-?\d+\.?\d*),(-?\d+\.?\d*)/
                ];

                for (const pattern of patterns) {
                    const match = decodedUrl.match(pattern);
                    if (match) {
                        const lat = parseFloat(match[1]);
                        const lng = parseFloat(match[2]);
                        if (lat >= 39 && lat <= 43 && lng >= 68 && lng <= 71) {
                            return [lat, lng];
                        }
                    }
                }

                return null;
            } catch (error) {
                console.error('Error extracting coordinates:', error);
                return null;
            }
        };

        const createMarkerIcon = (type, size = 14) => {
            const colors = {
                renovation: '#7c3aed',
                investment: '#2563eb',
                auction: '#ea580c',
                sold: '#dc2626',
                regular: '#059669'
            };

            return L.divIcon({
                html: `<div class="marker-icon marker-${type}" style="width:${size}px;height:${size}px;background:${colors[type]}"></div>`,
                className: 'custom-marker',
                iconSize: [size + 4, size + 4],
                iconAnchor: [(size + 4) / 2, (size + 4) / 2]
            });
        };

        // Toast Component
        const Toast = ({ toasts, removeToast }) => (
            <div className="toast-container">
                {toasts.map(toast => (
                    <div
                        key={toast.id}
                        className={`toast ${toast.type}`}
                        onClick={() => removeToast(toast.id)}
                    >
                        {toast.message}
                    </div>
                ))}
            </div>
        );

        // Loading Component
        const Loading = ({ show }) => (
            show ? (
                <div className="loading-overlay">
                    <div className="loading-spinner"></div>
                </div>
            ) : null
        );

        // Sidebar Component
        const Sidebar = ({ isOpen, onClose, item }) => (
            <div className={`sidebar ${isOpen ? 'open' : ''}`}>
                <div className="sidebar-header">
                    <h2 className="sidebar-title">
                        {item?.property_name || item?.['–û–±—ä–µ–∫—Ç_–Ω–æ–º–∏'] || 'Object Details'}
                    </h2>
                    <button className="close-btn" onClick={onClose}>
                        <i className="fas fa-times"></i>
                    </button>
                </div>
                <div className="sidebar-content">
                    {item && (
                        <>
                            <div className="section">
                                <h3 className="section-title">Basic Information</h3>
                                <table className="info-table">
                                    <tbody>
                                        <tr>
                                            <td>Name:</td>
                                            <td>{item.property_name || item['–û–±—ä–µ–∫—Ç_–Ω–æ–º–∏'] || 'N/A'}</td>
                                        </tr>
                                        <tr>
                                            <td>Type:</td>
                                            <td>
                                                <span className="badge badge-investment">
                                                    {item.type || item['–¢–∞–∫–ª–∏—Ñ_—Ç—É—Ä–∏_(–†–µ–Ω–æ–≤–∞—Ü–∏—è,_–ò–Ω–≤–µ—Å—Ç–∏—Ü–∏—è,_–ê—É–∫—Ü–∏–æ–Ω)'] || 'Unknown'}
                                                </span>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Location:</td>
                                            <td>{item.address || item['–ú–∞–Ω–∑–∏–ª_(–ú–§–ô,_–∫—û—á–∞)'] || 'N/A'}</td>
                                        </tr>
                                        <tr>
                                            <td>District:</td>
                                            <td>{item.district || item['–¢—É–º–∞–Ω'] || 'N/A'}</td>
                                        </tr>
                                        {item.land_area && (
                                            <tr>
                                                <td>Land Area:</td>
                                                <td>{item.land_area} –≥–∞</td>
                                            </tr>
                                        )}
                                        {item.start_price && (
                                            <tr>
                                                <td>Start Price:</td>
                                                <td>{Number(item.start_price).toLocaleString('uz-UZ')} —Å—É–º</td>
                                            </tr>
                                        )}
                                    </tbody>
                                </table>
                            </div>

                            {item.main_image && (
                                <div className="section">
                                    <h3 className="section-title">Image</h3>
                                    <img
                                        src={item.main_image}
                                        alt={item.property_name || 'Property'}
                                        style={{ width: "100%", maxHeight: "200px", objectFit: "cover", borderRadius: "8px" }}
                                        onError={(e) => e.target.style.display = 'none'}
                                    />
                                </div>
                            )}
                        </>
                    )}
                </div>
            </div>
        );

        // Layer Controls Component
        const LayerControls = ({ layers, onToggle, counts }) => (
            <div className="control-panel layer-controls">
                <h3 className="control-title">
                    <i className="fas fa-layer-group"></i>
                    Map Layers
                </h3>

                {Object.entries(layers).map(([key, layer]) => (
                    <button
                        key={key}
                        className={`layer-button ${layer.visible ? 'active' : ''}`}
                        onClick={() => onToggle(key)}
                    >
                        <div className="layer-button-content">
                            <i className={layer.icon}></i>
                            <span>{layer.name}</span>
                        </div>
                        <span className="count-badge">{counts[key] || 0}</span>
                    </button>
                ))}

                <div className="stats-panel">
                    <div className="control-title" style={{ marginBottom: '10px', fontSize: '14px' }}>
                        Statistics
                    </div>
                    <div className="stats-grid">
                        <div className="stats-item">
                            <span className="stats-label">Total:</span>
                            <span className="stats-value">
                                {Object.values(counts).reduce((a, b) => a + b, 0)}
                            </span>
                        </div>
                        <div className="stats-item">
                            <span className="stats-label">Visible:</span>
                            <span className="stats-value">
                                {Object.entries(layers).reduce((sum, [key, layer]) =>
                                    sum + (layer.visible ? (counts[key] || 0) : 0), 0
                                )}
                            </span>
                        </div>
                        {Object.entries(counts).map(([key, count]) => (
                            <div key={key} className="stats-item">
                                <span className="stats-label">{layers[key]?.name}:</span>
                                <span className="stats-value">{count}</span>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        );

        // Map Style Controls Component
        const MapStyleControls = ({ currentStyle, onStyleChange }) => (
            <div className="control-panel map-style-controls">
                <h3 className="control-title">
                    <i className="fas fa-map"></i>
                    Map Style
                </h3>

                {Object.entries(MAP_STYLES).map(([key, style]) => (
                    <button
                        key={key}
                        className={`style-button ${currentStyle === key ? 'active' : ''}`}
                        onClick={() => onStyleChange(key)}
                    >
                        {style.name}
                    </button>
                ))}
            </div>
        );

        // GeoJSON Controls Component
        const GeoJSONControls = ({
            geoJsonLayers,
            onLoad,
            onToggle,
            onRemove,
            onClear,
            status,
            filepath,
            setFilepath
        }) => (
            <div className="control-panel geojson-controls">
                <h3 className="control-title">
                    <i className="fas fa-file-code"></i>
                    GeoJSON Manager
                </h3>

                <div className="file-input-group">
                    <input
                        type="text"
                        className="file-input"
                        placeholder="/path/to/file.geojson"
                        value={filepath}
                        onChange={(e) => setFilepath(e.target.value)}
                    />
                    <div className="button-group">
                        <button className="primary-btn" onClick={onLoad}>
                            <i className="fas fa-upload"></i>
                            Load
                        </button>
                        <button className="secondary-btn" onClick={onClear}>
                            <i className="fas fa-trash"></i>
                            Clear All
                        </button>
                    </div>
                </div>

                {status && (
                    <div className="status-text">{status}</div>
                )}

                {geoJsonLayers.size > 0 && (
                    <div className="layer-list">
                        {Array.from(geoJsonLayers.entries()).map(([layerId, layerData]) => (
                            <div key={layerId} className="layer-item">
                                <span className="layer-name" title={layerId}>
                                    {layerId}
                                </span>
                                <div className="layer-actions">
                                    <button
                                        className={`action-btn toggle-btn ${layerData.visible ? '' : 'hidden'}`}
                                        onClick={() => onToggle(layerId)}
                                    >
                                        {layerData.visible ? 'Hide' : 'Show'}
                                    </button>
                                    <button
                                        className="action-btn remove-btn"
                                        onClick={() => onRemove(layerId)}
                                    >
                                        ‚úï
                                    </button>
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>
        );

        // Main App Component
        const InvestUzMap = () => {
            // State Management
            const [loading, setLoading] = useState(true);
            const [toasts, setToasts] = useState([]);
            const [sidebarOpen, setSidebarOpen] = useState(false);
            const [selectedItem, setSelectedItem] = useState(null);
            const [currentMapStyle, setCurrentMapStyle] = useState('osm');
            const [geoJsonFilepath, setGeoJsonFilepath] = useState('/tashkent_master_plan.geojson');
            const [geoJsonStatus, setGeoJsonStatus] = useState('Ready to load GeoJSON files...');
            const [dragActive, setDragActive] = useState(false);

            // Layer state
            const [layers, setLayers] = useState({
                regular: { name: 'API Data', icon: 'fas fa-building', visible: true },
                jsonData: { name: 'JSON Data', icon: 'fas fa-layer-group', visible: true },
                auction: { name: 'Auctions', icon: 'fas fa-gavel', visible: false },
                sold: { name: 'Sold Properties', icon: 'fas fa-check-circle', visible: true },
                geojson: { name: 'GeoJSON Layers', icon: 'fas fa-map', visible: true }
            });

            const [counts, setCounts] = useState({
                regular: 0,
                jsonData: 0,
                auction: 0,
                sold: 0,
                geojson: 0
            });

            // Refs
            const mapRef = useRef(null);
            const mapInstanceRef = useRef(null);
            const layerGroupsRef = useRef({});
            const geoJsonLayersRef = useRef(new Map());

            // Toast Management
            const addToast = useCallback((message, type = 'info') => {
                const id = Date.now();
                setToasts(prev => [...prev, { id, message, type }]);
                setTimeout(() => {
                    setToasts(prev => prev.filter(toast => toast.id !== id));
                }, 3000);
            }, []);

            const removeToast = useCallback((id) => {
                setToasts(prev => prev.filter(toast => toast.id !== id));
            }, []);

            // Map Initialization
            const initializeMap = useCallback(() => {
                if (!mapRef.current || mapInstanceRef.current) return;

                const map = L.map(mapRef.current, {
                    center: [41.311, 69.279],
                    zoom: 11,
                    minZoom: 10,
                    maxZoom: 18
                });

                // Initialize layer groups
                const groups = {
                    regular: L.markerClusterGroup({
                        chunkedLoading: true,
                        maxClusterRadius: 50,
                        spiderfyOnMaxZoom: true,
                        showCoverageOnHover: false,
                        disableClusteringAtZoom: 16
                    }),
                    jsonData: L.markerClusterGroup({
                        chunkedLoading: true,
                        maxClusterRadius: 50,
                        spiderfyOnMaxZoom: true,
                        showCoverageOnHover: false,
                        disableClusteringAtZoom: 16
                    }),
                    auction: L.markerClusterGroup({
                        chunkedLoading: true,
                        maxClusterRadius: 50,
                        spiderfyOnMaxZoom: true,
                        showCoverageOnHover: false,
                        disableClusteringAtZoom: 16
                    }),
                    sold: L.markerClusterGroup({
                        chunkedLoading: true,
                        maxClusterRadius: 50,
                        spiderfyOnMaxZoom: true,
                        showCoverageOnHover: false,
                        disableClusteringAtZoom: 16
                    })
                };

                // Add initial visible layers
                Object.entries(groups).forEach(([key, group]) => {
                    if (layers[key]?.visible) {
                        map.addLayer(group);
                    }
                });

                layerGroupsRef.current = groups;

                // Add initial map layer
                const osmLayer = L.tileLayer(MAP_STYLES.osm.url, {
                    attribution: MAP_STYLES.osm.attribution
                });
                osmLayer.addTo(map);

                mapInstanceRef.current = map;

                // Initialize coordinate system
                initProj4();
            }, [layers]);

            // Data Fetching Functions
            const fetchRegularData = useCallback(async () => {
                try {
                    const response = await fetch(API_ENDPOINTS.aktivs);
                    if (!response.ok) throw new Error(`API request failed: ${response.status}`);

                    const data = await response.json();
                    const lots = data.lots || data || [];

                    let processed = 0;
                    const group = layerGroupsRef.current.regular;

                    lots.forEach((lot, index) => {
                        if (!lot.lat || !lot.lng) return;

                        const marker = L.marker([parseFloat(lot.lat), parseFloat(lot.lng)], {
                            icon: createMarkerIcon('regular')
                        });

                        const popup = `
                            <div class="popup-header">${lot.property_name || 'Investment Property'}</div>
                            ${lot.main_image ? `<img src="${lot.main_image}" class="popup-image" onerror="this.style.display='none'">` : ''}
                            <div class="popup-details">
                                <p><strong>District:</strong> ${lot.district || 'N/A'}</p>
                                <p><strong>Address:</strong> ${lot.address || 'N/A'}</p>
                                ${lot.land_area ? `<p><strong>Area:</strong> ${lot.land_area} –≥–∞</p>` : ''}
                                ${lot.start_price ? `<p><strong>Price:</strong> ${Number(lot.start_price).toLocaleString('uz-UZ')} —Å—É–º</p>` : ''}
                            </div>
                            <button class="details-btn" onclick="window.showDetails('${lot.id || index}', 'regular')">
                                View Details
                            </button>
                        `;

                        marker.bindPopup(popup, { maxWidth: 300 });
                        marker.lotData = lot;
                        group.addLayer(marker);
                        processed++;
                    });

                    setCounts(prev => ({ ...prev, regular: processed }));
                    addToast(`Loaded ${processed} investment properties`, 'success');
                    return processed > 0;
                } catch (error) {
                    console.error('Error fetching regular data:', error);
                    addToast('Failed to load investment data', 'error');
                    return false;
                }
            }, [addToast]);

            const fetchJsonData = useCallback(async () => {
                try {
                    const response = await fetch(API_ENDPOINTS.jsonData);
                    if (!response.ok) return false;

                    const data = await response.json();
                    if (!Array.isArray(data)) return false;

                    let processed = 0;
                    const group = layerGroupsRef.current.jsonData;

                    data.forEach((item, index) => {
                        const coordinates = extractCoordinatesFromUrl(item['–¢–∞–∫–ª–∏—Ñ_–•–∞—Ä–∏—Ç–∞']);
                        if (!coordinates) return;

                        const type = item['–¢–∞–∫–ª–∏—Ñ_—Ç—É—Ä–∏_(–†–µ–Ω–æ–≤–∞—Ü–∏—è,_–ò–Ω–≤–µ—Å—Ç–∏—Ü–∏—è,_–ê—É–∫—Ü–∏–æ–Ω)'];
                        let markerType = 'investment';
                        if (type === '–†–µ–Ω–æ–≤–∞—Ü–∏—è') markerType = 'renovation';
                        else if (type === '–ê—É–∫—Ü–∏–æ–Ω') markerType = 'auction';

                        const marker = L.marker(coordinates, {
                            icon: createMarkerIcon(markerType)
                        });

                        const popup = `
                            <div class="popup-header">${item['–û–±—ä–µ–∫—Ç_–Ω–æ–º–∏'] || 'JSON Object'}</div>
                            <div class="popup-details">
                                <p><strong>Type:</strong> <span class="badge badge-${markerType}">${type || 'Unknown'}</span></p>
                                <p><strong>District:</strong> ${item['–¢—É–º–∞–Ω'] || 'N/A'}</p>
                                <p><strong>Address:</strong> ${item['–ú–∞–Ω–∑–∏–ª_(–ú–§–ô,_–∫—û—á–∞)'] || 'N/A'}</p>
                            </div>
                            <button class="details-btn" onclick="window.showDetails('${index}', 'jsonData')">
                                View Details
                            </button>
                        `;

                        marker.bindPopup(popup, { maxWidth: 300 });
                        marker.itemData = item;
                        group.addLayer(marker);
                        processed++;
                    });

                    setCounts(prev => ({ ...prev, jsonData: processed }));
                    addToast(`Loaded ${processed} JSON objects`, 'success');
                    return processed > 0;
                } catch (error) {
                    console.error('Error fetching JSON data:', error);
                    return false;
                }
            }, [addToast]);

            const fetchAuctionData = useCallback(async () => {
                try {
                    const response = await fetch(API_ENDPOINTS.auction);
                    if (!response.ok) return false;

                    const data = await response.json();
                    const lots = data.lots || [];

                    let processed = 0;
                    const group = layerGroupsRef.current.auction;

                    lots.forEach((lot, index) => {
                        if (!lot.lat || !lot.lng) return;

                        const marker = L.marker([parseFloat(lot.lat), parseFloat(lot.lng)], {
                            icon: createMarkerIcon('auction')
                        });

                        const popup = `
                            <div class="popup-header">${lot.property_name || 'Auction Property'}</div>
                            ${lot.main_image ? `<img src="${lot.main_image}" class="popup-image" onerror="this.style.display='none'">` : ''}
                            <div class="popup-details">
                                <p><strong>Start Price:</strong> ${lot.start_price ? Number(lot.start_price).toLocaleString('uz-UZ') + ' —Å—É–º' : 'N/A'}</p>
                                <p><strong>Auction Date:</strong> ${lot.auction_date || 'N/A'}</p>
                                <p><strong>Location:</strong> ${lot.region || ''} ${lot.area || ''} ${lot.address || ''}</p>
                                <p><strong>Area:</strong> ${lot.land_area || 'N/A'} –≥–∞</p>
                                <p><strong>Status:</strong> <span class="badge badge-auction">Auction</span></p>
                            </div>
                            <button class="details-btn" onclick="window.showDetails('${index}', 'auction')">
                                View Details
                            </button>
                        `;

                        marker.bindPopup(popup, { maxWidth: 300 });
                        marker.auctionData = lot;
                        group.addLayer(marker);
                        processed++;
                    });

                    setCounts(prev => ({ ...prev, auction: processed }));
                    addToast(`Loaded ${processed} auction properties`, 'success');
                    return processed > 0;
                } catch (error) {
                    console.error('Error fetching auction data:', error);
                    return false;
                }
            }, [addToast]);

            const fetchSoldData = useCallback(async () => {
                try {
                    const response = await fetch(API_ENDPOINTS.sold);
                    if (!response.ok) return false;

                    const data = await response.json();
                    const lots = data.lots || [];

                    let processed = 0;
                    const group = layerGroupsRef.current.sold;

                    lots.forEach((lot, index) => {
                        if (!lot.lat || !lot.lng) return;

                        const marker = L.marker([parseFloat(lot.lat), parseFloat(lot.lng)], {
                            icon: createMarkerIcon('sold')
                        });

                        const popup = `
                            <div class="popup-header">üèÜ ${lot.property_name || 'Sold Property'}</div>
                            ${lot.main_image ? `<img src="${lot.main_image}" class="popup-image" onerror="this.style.display='none'">` : ''}
                            <div class="popup-details">
                                <p><strong>Sold Price:</strong> ${lot.sold_price ? Number(lot.sold_price).toLocaleString('uz-UZ') + ' —Å—É–º' : 'N/A'}</p>
                                <p><strong>Start Price:</strong> ${lot.start_price ? Number(lot.start_price).toLocaleString('uz-UZ') + ' —Å—É–º' : 'N/A'}</p>
                                <p><strong>Winner:</strong> ${lot.winner_name || 'N/A'}</p>
                                <p><strong>Auction Date:</strong> ${lot.auction_date || 'N/A'}</p>
                                <p><strong>Location:</strong> ${lot.region || ''} ${lot.area || ''} ${lot.address || ''}</p>
                                <p><strong>Status:</strong> <span class="badge badge-sold">‚úÖ Sold</span></p>
                            </div>
                            <button class="details-btn" onclick="window.showDetails('${index}', 'sold')">
                                View Details
                            </button>
                        `;

                        marker.bindPopup(popup, { maxWidth: 300 });
                        marker.soldData = lot;
                        group.addLayer(marker);
                        processed++;
                    });

                    setCounts(prev => ({ ...prev, sold: processed }));
                    addToast(`Loaded ${processed} sold properties`, 'success');
                    return processed > 0;
                } catch (error) {
                    console.error('Error fetching sold data:', error);
                    return false;
                }
            }, [addToast]);

            // Layer Toggle
            const toggleLayer = useCallback((layerKey) => {
                setLayers(prev => {
                    const newLayers = {
                        ...prev,
                        [layerKey]: { ...prev[layerKey], visible: !prev[layerKey].visible }
                    };

                    // Update map layers
                    const map = mapInstanceRef.current;
                    const group = layerGroupsRef.current[layerKey];

                    if (group && map) {
                        if (newLayers[layerKey].visible) {
                            map.addLayer(group);
                        } else {
                            map.removeLayer(group);
                        }
                    }

                    return newLayers;
                });
            }, []);

            // Map Style Change
            const changeMapStyle = useCallback((styleKey) => {
                const map = mapInstanceRef.current;
                if (!map) return;

                // Remove current layers
                map.eachLayer(layer => {
                    if (layer._url) { // Tile layer
                        map.removeLayer(layer);
                    }
                });

                const style = MAP_STYLES[styleKey];

                if (styleKey === 'hybrid') {
                    const baseLayer = L.tileLayer(style.baseUrl, { attribution: style.attribution });
                    const labelLayer = L.tileLayer(style.labelUrl, { attribution: '' });
                    map.addLayer(baseLayer);
                    map.addLayer(labelLayer);
                } else {
                    const layer = L.tileLayer(style.url, { attribution: style.attribution });
                    map.addLayer(layer);
                }

                setCurrentMapStyle(styleKey);
            }, []);

            // GeoJSON Functions
            const loadGeoJSON = useCallback(async (filepath) => {
                if (!filepath.trim()) {
                    addToast('Please enter a file path', 'error');
                    return;
                }

                try {
                    setGeoJsonStatus('Loading GeoJSON...');
                    const response = await fetch(filepath);
                    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

                    const data = await response.json();
                    if (!data.features || !Array.isArray(data.features)) {
                        throw new Error('Invalid GeoJSON format');
                    }

                    const layerId = filepath.split('/').pop().replace(/\.[^/.]+$/, '');

                    // Remove existing layer if it exists
                    if (geoJsonLayersRef.current.has(layerId)) {
                        const existingLayer = geoJsonLayersRef.current.get(layerId);
                        mapInstanceRef.current.removeLayer(existingLayer.group);
                        geoJsonLayersRef.current.delete(layerId);
                    }

                    const featureGroup = L.featureGroup();

                    // Process features
                    data.features.forEach(feature => {
                        const layer = createGeoJSONLayer(feature);
                        if (layer) {
                            addGeoJSONPopup(layer, feature.properties);
                            featureGroup.addLayer(layer);
                        }
                    });

                    geoJsonLayersRef.current.set(layerId, {
                        group: featureGroup,
                        visible: true
                    });

                    mapInstanceRef.current.addLayer(featureGroup);
                    setCounts(prev => ({ ...prev, geojson: prev.geojson + 1 }));

                    // Fit bounds if this is the first layer
                    if (geoJsonLayersRef.current.size === 1) {
                        try {
                            mapInstanceRef.current.fitBounds(featureGroup.getBounds(), { padding: [20, 20] });
                        } catch (e) {
                            console.warn('Could not fit bounds:', e);
                        }
                    }

                    setGeoJsonStatus(`${data.features.length} objects loaded`);
                    addToast('GeoJSON loaded successfully', 'success');

                } catch (error) {
                    console.error('Error loading GeoJSON:', error);
                    setGeoJsonStatus(`Error: ${error.message}`);
                    addToast(`Failed to load GeoJSON: ${error.message}`, 'error');
                }
            }, [addToast]);

            const createGeoJSONLayer = useCallback((feature) => {
                if (!feature.geometry || !feature.geometry.coordinates) return null;

                const geomType = feature.geometry.type;
                const coords = feature.geometry.coordinates;

                try {
                    switch (geomType) {
                        case 'Point':
                            const latLng = convertCoordinates(coords);
                            if (!latLng) return null;
                            return L.circleMarker(latLng, {
                                radius: 6,
                                fillColor: '#ff7f0e',
                                color: '#fff',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.8
                            });

                        case 'LineString':
                            const latLngs = coords.map(coord => convertCoordinates(coord)).filter(Boolean);
                            if (latLngs.length === 0) return null;
                            return L.polyline(latLngs, {
                                color: '#1f77b4',
                                weight: 3,
                                opacity: 0.8
                            });

                        case 'Polygon':
                            const rings = coords.map(ring =>
                                ring.map(coord => convertCoordinates(coord)).filter(Boolean)
                            ).filter(ring => ring.length > 0);
                            if (rings.length === 0) return null;

                            const polygon = L.polygon(rings, {
                                fillColor: '#ff7f0e',
                                weight: 1.5,
                                opacity: 0.8,
                                color: '#ffffff',
                                fillOpacity: 0.7
                            });
                            return polygon;

                        case 'MultiPolygon':
                            const multiLatLngs = coords.map(polygon =>
                                polygon.map(ring =>
                                    ring.map(coord => convertCoordinates(coord)).filter(Boolean)
                                ).filter(ring => ring.length > 0)
                            ).filter(polygon => polygon.length > 0);
                            if (multiLatLngs.length === 0) return null;

                            const multiPolygon = L.polygon(multiLatLngs, {
                                fillColor: '#ff7f0e',
                                weight: 1.5,
                                opacity: 0.8,
                                color: '#ffffff',
                                fillOpacity: 0.7
                            });
                            return multiPolygon;

                        default:
                            console.warn('Unsupported geometry type:', geomType);
                            return null;
                    }
                } catch (error) {
                    console.warn('Error creating feature layer:', error);
                    return null;
                }
            }, []);

            const addGeoJSONPopup = useCallback((layer, properties) => {
                if (!properties) return;

                const titleKey = Object.keys(properties).find(key =>
                    ['name', 'title', 'id', 'funksiya', 'function', 'property_name'].includes(key.toLowerCase())
                ) || Object.keys(properties)[0];

                const title = properties[titleKey] || 'GeoJSON Object';

                layer.bindPopup(() => {
                    let content = `<div class="popup-header">${title}</div><div class="popup-details">`;

                    Object.entries(properties).slice(0, 8).forEach(([key, value]) => {
                        if (value !== null && value !== '') {
                            const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            content += `<p><strong>${displayKey}:</strong> ${value}</p>`;
                        }
                    });

                    content += '</div>';
                    return content;
                }, {
                    maxWidth: 400,
                    className: 'geojson-popup'
                });
            }, []);

            const toggleGeoJSONLayer = useCallback((layerId) => {
                const layerData = geoJsonLayersRef.current.get(layerId);
                if (!layerData) return;

                const map = mapInstanceRef.current;
                if (layerData.visible) {
                    map.removeLayer(layerData.group);
                } else {
                    map.addLayer(layerData.group);
                }

                geoJsonLayersRef.current.set(layerId, {
                    ...layerData,
                    visible: !layerData.visible
                });
            }, []);

            const removeGeoJSONLayer = useCallback((layerId) => {
                const layerData = geoJsonLayersRef.current.get(layerId);
                if (!layerData) return;

                mapInstanceRef.current.removeLayer(layerData.group);
                geoJsonLayersRef.current.delete(layerId);
                setCounts(prev => ({ ...prev, geojson: Math.max(0, prev.geojson - 1) }));
                addToast(`${layerId} layer removed`, 'info');
            }, [addToast]);

            const clearAllGeoJSON = useCallback(() => {
                geoJsonLayersRef.current.forEach((layerData) => {
                    mapInstanceRef.current.removeLayer(layerData.group);
                });
                geoJsonLayersRef.current.clear();
                setCounts(prev => ({ ...prev, geojson: 0 }));
                setGeoJsonStatus('All GeoJSON layers cleared');
                addToast('All GeoJSON layers cleared', 'info');
            }, [addToast]);

            // Global functions for popup buttons
            window.showDetails = useCallback((id, type) => {
                let item = null;

                // Find the item based on type
                const groups = layerGroupsRef.current;
                if (groups[type]) {
                    groups[type].eachLayer(layer => {
                        if (layer.lotData && (layer.lotData.id === id || layer.lotData.id === `lot-${id}`)) {
                            item = layer.lotData;
                        } else if (layer.itemData) {
                            item = layer.itemData;
                        } else if (layer.auctionData) {
                            item = layer.auctionData;
                        } else if (layer.soldData) {
                            item = layer.soldData;
                        }
                    });
                }

                if (item) {
                    setSelectedItem(item);
                    setSidebarOpen(true);
                }
            }, []);

            // Drag and Drop
            const handleDragEnter = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragActive(true);
            }, []);

            const handleDragLeave = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragActive(false);
            }, []);

            const handleDragOver = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
            }, []);

            const handleDrop = useCallback(async (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragActive(false);

                const files = Array.from(e.dataTransfer.files);
                const geoJsonFile = files.find(file =>
                    file.name.toLowerCase().endsWith('.geojson') ||
                    file.name.toLowerCase().endsWith('.json')
                );

                if (geoJsonFile) {
                    try {
                        const text = await geoJsonFile.text();
                        const data = JSON.parse(text);

                        // Process the GeoJSON data similar to loadGeoJSON
                        if (!data.features || !Array.isArray(data.features)) {
                            throw new Error('Invalid GeoJSON format');
                        }

                        const layerId = geoJsonFile.name.replace(/\.[^/.]+$/, '');

                        const featureGroup = L.featureGroup();

                        data.features.forEach(feature => {
                            const layer = createGeoJSONLayer(feature);
                            if (layer) {
                                addGeoJSONPopup(layer, feature.properties);
                                featureGroup.addLayer(layer);
                            }
                        });

                        geoJsonLayersRef.current.set(layerId, {
                            group: featureGroup,
                            visible: true
                        });

                        mapInstanceRef.current.addLayer(featureGroup);
                        setCounts(prev => ({ ...prev, geojson: prev.geojson + 1 }));

                        addToast(`${geoJsonFile.name} loaded successfully`, 'success');
                    } catch (error) {
                        addToast(`Failed to load ${geoJsonFile.name}: ${error.message}`, 'error');
                    }
                } else {
                    addToast('Only GeoJSON (.geojson, .json) files are supported', 'error');
                }
            }, [createGeoJSONLayer, addGeoJSONPopup, addToast]);

            // Data Loading Effect
            useEffect(() => {
                const loadAllData = async () => {
                    if (!mapInstanceRef.current) return;

                    setLoading(true);

                    try {
                        // Load all data sources concurrently
                        const results = await Promise.allSettled([
                            fetchRegularData(),
                            fetchJsonData(),
                            fetchAuctionData(),
                            fetchSoldData()
                        ]);

                        // Count successful loads
                        const successCount = results.filter(result =>
                            result.status === 'fulfilled' && result.value
                        ).length;

                        if (successCount > 0) {
                            // Auto-load default GeoJSON file
                            setTimeout(() => {
                                loadGeoJSON('/tashkent_master_plan.geojson');
                            }, 1000);

                            // Fit map to show all data
                            const allLayers = [];
                            Object.values(layerGroupsRef.current).forEach(group => {
                                group.eachLayer(layer => allLayers.push(layer));
                            });

                            if (allLayers.length > 0) {
                                const group = L.featureGroup(allLayers);
                                try {
                                    mapInstanceRef.current.fitBounds(group.getBounds(), {
                                        padding: [50, 50]
                                    });
                                } catch (e) {
                                    // Fallback to default center
                                    mapInstanceRef.current.setView([41.311, 69.279], 11);
                                }
                            } else {
                                mapInstanceRef.current.setView([41.311, 69.279], 11);
                            }

                            const totalLoaded = Object.values(counts).reduce((a, b) => a + b, 0);
                            addToast(`Successfully loaded ${totalLoaded} data points`, 'success');
                        } else {
                            addToast('No data could be loaded. Please check server connectivity.', 'warning');
                            mapInstanceRef.current.setView([41.311, 69.279], 11);
                        }
                    } catch (error) {
                        console.error('Error during data loading:', error);
                        addToast('Error during initialization', 'error');
                        mapInstanceRef.current.setView([41.311, 69.279], 11);
                    } finally {
                        setLoading(false);
                    }
                };

                // Initialize map first, then load data
                if (mapRef.current && !mapInstanceRef.current) {
                    initializeMap();
                    setTimeout(loadAllData, 100); // Small delay to ensure map is ready
                }
            }, [
                initializeMap,
                fetchRegularData,
                fetchJsonData,
                fetchAuctionData,
                fetchSoldData,
                loadGeoJSON,
                addToast,
                counts
            ]);

            // Memoized components
            const memoizedLayerControls = useMemo(() => (
                <LayerControls
                    layers={layers}
                    onToggle={toggleLayer}
                    counts={counts}
                />
            ), [layers, counts, toggleLayer]);

            const memoizedMapStyleControls = useMemo(() => (
                <MapStyleControls
                    currentStyle={currentMapStyle}
                    onStyleChange={changeMapStyle}
                />
            ), [currentMapStyle, changeMapStyle]);

            const memoizedGeoJSONControls = useMemo(() => (
                <GeoJSONControls
                    geoJsonLayers={geoJsonLayersRef.current}
                    onLoad={() => loadGeoJSON(geoJsonFilepath)}
                    onToggle={toggleGeoJSONLayer}
                    onRemove={removeGeoJSONLayer}
                    onClear={clearAllGeoJSON}
                    status={geoJsonStatus}
                    filepath={geoJsonFilepath}
                    setFilepath={setGeoJsonFilepath}
                />
            ), [
                geoJsonFilepath,
                geoJsonStatus,
                loadGeoJSON,
                toggleGeoJSONLayer,
                removeGeoJSONLayer,
                clearAllGeoJSON
            ]);

            return (
                <div className="app-container">
                    {/* Header */}
                    <header className="app-header">
                        <div className="app-logo">
                            <i className="fas fa-map-marked-alt fa-2x"></i>
                            <div className="app-title">InvestUz - Investment Map</div>
                        </div>
                        <div className="header-controls">
                            <div className="lang-switcher">
                                <button className="lang-btn active">UZ</button>
                                <button className="lang-btn">RU</button>
                                <button className="lang-btn">EN</button>
                            </div>
                        </div>
                    </header>

                    {/* Main Content */}
                    <div className="main-content">
                        <div className="map-container">
                            {/* Map */}
                            <div
                                ref={mapRef}
                                id="map"
                                onDragEnter={handleDragEnter}
                                onDragLeave={handleDragLeave}
                                onDragOver={handleDragOver}
                                onDrop={handleDrop}
                            />

                            {/* Drag Overlay */}
                            <div className={`drag-overlay ${dragActive ? 'active' : ''}`}>
                                <div>
                                    <i className="fas fa-upload fa-3x" style={{ marginBottom: '20px' }}></i>
                                    <div>Drop GeoJSON files here to load them</div>
                                </div>
                            </div>

                            {/* Control Panels */}
                            {memoizedMapStyleControls}
                            {memoizedLayerControls}
                            {memoizedGeoJSONControls}
                        </div>

                        {/* Sidebar */}
                        <Sidebar
                            isOpen={sidebarOpen}
                            onClose={() => setSidebarOpen(false)}
                            item={selectedItem}
                        />
                    </div>

                    {/* Loading Overlay */}
                    <Loading show={loading} />

                    {/* Toast Notifications */}
                    <Toast toasts={toasts} removeToast={removeToast} />
                </div>
            );
        };

        // Render the app
        ReactDOM.render(<InvestUzMap />, document.getElementById('root'));
    </script>
</body>
</html>
